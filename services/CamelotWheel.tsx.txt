import React, { useMemo } from 'react';

interface CamelotWheelProps {
  currentKey: string | null;
  onKeySelect: (key: string) => void;
  compatibleKeys: string[];
  currentKeyLabel?: string;
}

const CamelotWheel: React.FC<CamelotWheelProps> = ({ 
    currentKey, 
    onKeySelect, 
    compatibleKeys,
    currentKeyLabel = "Current Key"
}) => {
  const keys = useMemo(() => {
    const result = [];
    // Outer Circle (B - Major)
    for (let i = 1; i <= 12; i++) {
      result.push({ number: i, mode: 'B', label: `${i}B` });
    }
    // Inner Circle (A - Minor)
    for (let i = 1; i <= 12; i++) {
      result.push({ number: i, mode: 'A', label: `${i}A` });
    }
    return result;
  }, []);

  // Helper to create donut segments
  const createSegmentPath = (index: number, isInner: boolean) => {
    const sliceAngle = (2 * Math.PI) / 12;
    // Rotate -90deg (top) plus offset for index
    const startAngle = (index - 1) * sliceAngle - Math.PI / 2 - (sliceAngle / 2); 
    const endAngle = startAngle + sliceAngle;

    // Adjusted radii to ensure it fits perfectly inside 300x300 without clipping strokes
    const outerRadius = 145; 
    const middleRadius = 95;
    const innerRadius = 45;

    const r1 = isInner ? middleRadius : outerRadius;
    const r2 = isInner ? innerRadius : middleRadius;

    const x1 = Math.cos(startAngle) * r1 + 150; // Center 150,150
    const y1 = Math.sin(startAngle) * r1 + 150;
    const x2 = Math.cos(endAngle) * r1 + 150;
    const y2 = Math.sin(endAngle) * r1 + 150;
    const x3 = Math.cos(endAngle) * r2 + 150;
    const y3 = Math.sin(endAngle) * r2 + 150;
    const x4 = Math.cos(startAngle) * r2 + 150;
    const y4 = Math.sin(startAngle) * r2 + 150;

    return `M ${x1} ${y1} A ${r1} ${r1} 0 0 1 ${x2} ${y2} L ${x3} ${y3} A ${r2} ${r2} 0 0 0 ${x4} ${y4} Z`;
  };

  // Colors roughly based on standard Camelot colors
  const getKeyColor = (number: number, isInner: boolean) => {
     const colors = [
        '#EF4444', // 1 - Red
        '#F97316', // 2 - Orange
        '#EAB308', // 3 - Yellow
        '#84CC16', // 4 - Lime
        '#22C55E', // 5 - Green
        '#10B981', // 6 - Emerald
        '#06B6D4', // 7 - Cyan
        '#0EA5E9', // 8 - Sky
        '#3B82F6', // 9 - Blue
        '#6366F1', // 10 - Indigo
        '#8B5CF6', // 11 - Violet
        '#D946EF', // 12 - Fuchsia
     ];
     let color = colors[(number - 1) % 12];
     if (isInner) {
         return color;
     }
     return color;
  };

  return (
    <div className="relative w-full max-w-[300px] aspect-square mx-auto select-none">
      <svg width="100%" height="100%" viewBox="0 0 300 300" className="overflow-visible">
        {/* Background Circle - slightly smaller than viewbox */}
        <circle cx="150" cy="150" r="148" fill="#1e293b" />
        {keys.map((k) => {
            const isInner = k.mode === 'A';
            const isActive = currentKey === k.label;
            const isCompatible = compatibleKeys.includes(k.label);
            const baseColor = getKeyColor(k.number, isInner);
            
            let fill = baseColor;
            let opacity = 0.3;
            let stroke = '#0f172a';
            let strokeWidth = 1;

            if (isActive) {
                opacity = 1;
                stroke = '#ffffff';
                strokeWidth = 3;
            } else if (isCompatible) {
                opacity = 0.8;
                stroke = '#ffffff';
                strokeWidth = 1;
            }

            // Adjust opacity for inner ring to distinguish
            if (isInner && !isActive && !isCompatible) opacity = 0.2;

            // Center calculation for text
            const sliceAngle = (2 * Math.PI) / 12;
            const angle = (k.number - 1) * sliceAngle - Math.PI / 2;
            // Adjusted text positioning based on new radii
            const radius = isInner ? 70 : 120;
            const tx = Math.cos(angle) * radius + 150;
            const ty = Math.sin(angle) * radius + 150;

            return (
                <g 
                    key={k.label} 
                    onClick={() => onKeySelect(k.label)} 
                    className="cursor-pointer transition-all duration-200 hover:opacity-100"
                    style={{ filter: isActive ? 'drop-shadow(0 0 8px rgba(255,255,255,0.5))' : 'none' }}
                >
                    <path 
                        d={createSegmentPath(k.number, isInner)} 
                        fill={fill} 
                        fillOpacity={opacity}
                        stroke={stroke}
                        strokeWidth={strokeWidth}
                    />
                    <text 
                        x={tx} 
                        y={ty} 
                        dy="0.35em" 
                        textAnchor="middle" 
                        fontSize={isInner ? "10" : "12"}
                        fontWeight="bold"
                        fill={isActive ? '#000' : 'rgba(255,255,255,0.9)'}
                        pointerEvents="none"
                    >
                        {k.label}
                    </text>
                </g>
            );
        })}
        {/* Center Logo/Status */}
        <circle cx="150" cy="150" r="40" fill="#0f172a" stroke="#334155" strokeWidth="2" />
        <text x="150" y="145" textAnchor="middle" fill="#94a3b8" fontSize="10">{currentKeyLabel}</text>
        <text x="150" y="165" textAnchor="middle" fill="#fff" fontSize="18" fontWeight="bold">{currentKey || '-'}</text>
      </svg>
    </div>
  );
};

export default CamelotWheel;